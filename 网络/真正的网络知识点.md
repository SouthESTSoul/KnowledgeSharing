



## 网络OSI七层和TCP/IP四层

- 七层是理论模型，四层是是实际的实践。
- ![1.png](https://i.loli.net/2021/05/23/PXxSMv8zgL64yjf.png)

## TCP 和 UDP 的区别是什么？

### TCP

- 面向连接
- 保证数据的准确性和顺序
- 以流的形式传输

#### TCP是怎么保证数据的可靠性的？

- 校验和
  - 简单来说就是吧数据包每16bit分割，然后加起来取反，以此来让收到这个数据包的人校验数据有没有问题，当然这种方式会有失效的情况，就是虽然改了但是校验和还是一样。
- 应答机制和序列号
  - 对每个数据包都进行了编号，收到都需要应答，也是以此来保证顺序性的，因为有编号了嘛
  - 并不需要每次收到数据包都发送一个应答，可以稍微等一会，看看有没有其他数据要传顺带着捎上，减少发送频率。
- 超时重传
  - 发送数据包之后一段时间没有收到响应，就重新传数据包
- 流量控制
  - 防止数据包发送太快超出缓冲区而导致丢包，可以告诉对面缓冲区的大小，该发多大的包
- 拥塞控制
  - 慢开始，一开始传输少量数据看看网络情况，然后逐渐提高传输效率，如果传输出了问题，又会降低传输效率。

### UDP

- 无连接
  - 广播机制，可以一对一也可以一对多
- 可能丢包，不保证顺序
- 以数据包的形式传输



## 三次握手和四次挥手讲一讲？ 为什么三次握手不是两次和四次？为什么挥手时最后要等待 2MSL  时间？

https://zhuanlan.zhihu.com/p/199284611?from=timeline

- 第一次握手：请求方发送连接的请求
- 第二次握手：接收方发送请求连接的请求，并表示上一个请求已经收到
- 第三次握手：请求方发送已经收到请求的消息，这个数据包中已经可以携带数据

![2.png](https://i.loli.net/2021/05/23/IkJlA1eqVOKMmSL.png)

- 第一次挥手：请求方发送 中断的请求
- 第二次挥手：接收方表示请求已收到，还要发送之前没发送完的数据，（如果没有要发送的数据，其实第二次和第三次理论上是可以合并的，也就是说可以合并成三次挥手）
- 第三次挥手：接收方发送中断请求
- 第四次挥手：请求方表示中断请求已收到，中断连接

![FS_QW(64K2UN2(P)4`F4R6A.png](https://i.loli.net/2021/05/23/hNYAcDxdEXC1PFU.png)



### 为什么三次握手不是两次和四次

两次握手并不能确定接收方已经能正确发送报文了。

四次就冗余了，三次已经能确定两边的双全工通信。

### TIME_WAIT的2MSL时间是为了什么？

主动断开放才会进入TIME_WAIT

其中最后一个ACK报文是由客户端发往服务器。假设这个ACK报文在网络中被丢弃了，那么服务器端收不到这个确认ACK，**服务器端需要向客户端再次发送FIN。**
这就是为什么TIME_WAIT状态持续2倍的最长报文段生存时间

- 1MSL时间留给最后的ACK确认报文段到达服务器端

- 1MSL时间留给服务器端再次发送的FIN。

#### 如果没有这个2MSL会怎么样？

- 被动关闭方没有收到自己FIN包的ACK，重传到主动关闭方，但是连接已经关闭了，协议栈会认为对方疯了，都还没建立连接你给我来个 FIN 包？，于是回复一个 RST 包给被动关闭方。被动关闭方就会收到一个错误。
- 防止链路上已经关闭的连接的残余数据包干扰其他数据包
  - 比如防止已经断开的连接 1 中在链路中残留的 FIN 包终止掉新的连接 2(重用了连接 1 的所有的 五元组)

### TIME_WAIT带来的影响

​	一个连接进入 TIME_WAIT 状态后需要等待 2*MSL(一般是 1 到 4 分钟)那么长的时间才能断开连接释放连接占用的资源

- 作为服务器，短时间内关闭了大量的 Client 连接，就会造成服务器上出现大量的 TIME_WAIT 连接，占据大量的 tuple，严重消耗着服务器的资源。
- 作为客户端，短时间内大量的短连接，会大量消耗的 Client 机器的端口，毕竟端口只有 65535 个，端口被耗尽了，后续就无法在发起新的连接了。

#### 

## HTTP 和 HTTPS 的区别有哪些？

### HTTP

- 明文传输，不安全
- 无状态
- 端口80

### HTTPS

- 使用TLS加密，安全
- 有状态
  - 有状态的连接：都通过加密确定身份了，所有请求都基于这个身份确认来发送，当然有状态啦
- 端口443
- HTTPS一般用非对称加密（RSA）去加密 对称加密算法的私钥之后发送，进行信息传输。因为非对称加密速度较慢。

## HTTPS 建立连接的过程是什么样的？

https://segmentfault.com/a/1190000039311600

1. 客户端请求服务器建立安全连接，附加客户端支持的SSL与TLS版本、支持的加密算法版本、**随机数**。

   > 加密算法与安全协议版本有很多，但服务不一定支持最新版本的协议预算法。所以客户端把所以支持的版本发送给服务器，让服务器去选择。
   >
   > 随机数非常重要，前面讲hash算法的时候讲到，随机数是一个动态因子，让hash算法更加安全。同时，随机数也参与了对称密钥的生成。

2. 服务器响应请求，附加选择的协议版本、加密算法版本、**服务器随机数**。

   > 服务器从客户端支持的协议版本中，选择一套自己最喜欢的。
   >
   > 为了辨别消息是由哪一方加密并发出的，需要准备两个对称密钥。因此服务器也需要产生一个随机数。

3. 服务器向客户端发送证书

   > 服务器向客户端发送自己证书，其中就包含了服务器的公钥。

4. 服务器发送hello done表示hello阶段结束

5. 客户端验证证书，拿到服务器公钥；利用两个随机数，生成pre-master secret，并使用服务器的公钥加密发送给服务器。此时还会带上利用**随机数**进行加密的信息和这个信息的**hash值**

   > 证书验证步骤参考上面的证书小节；
   >
   > pre-master secret是一个非常重要的东西，双方利用pre-master secret生成master-secret，利用前面的两个随机数生成两个对称加密密钥和两个HMAC密钥，两对密钥分别用于客户端加密和服务器加密。

6. 客户端发送changeCipherSpec提示服务器此后使用pre-master secret产生的密钥加密通信

7. 客户端发送FIN报文，表示结束

8. 服务器也发送changeCipherSpec报文

9. 服务器也发送FIN报文，表示结束

10. 双方可以开始安全通信了

还会有选择加密协议和版本的请求，两张图结合起来看。

![img](https://i.loli.net/2021/05/23/ydhqesrgSHVF2K8.png)

![img](https://i.loli.net/2021/05/23/LZkm1WuGMrRXHes.png)

## HTTP和RPC的区别？

比较的应该是HTTP协议和RPC框架里支持的那些协议的区别。

HTTP是应用层协议，主要解决如何包装数据。RPC的那些协议的本质也是解决怎么更快地包装数据，解决一些业务问题，比如长连接下请求与回复的一致性。

- RPC负责应用间的通信，HTTP包含更多无意义的内容，比如换行符、回车符等
- 一般RPC为了性能，会采用异步通信的方式
  - 在http短连接的情况下，返回的一致性由这个连接来保证
  - 在http长连接下，一个连接发送了两个http的请求，返回后无法确保识别出来这两个应答是哪个请求的
    - 在Dubbo中，默认协议是为：dubbo协议（默认）：单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用（单一、长连接，异步传输，默认使用 Hessian2 序列化）
  - HTTP协议属于无状态协议，在并发高的情况下，我们希望的是每次都是异步调用，要求客户端无法请求和响应进行关联。
- grpc基于http2，更容易跨语言支持。
  - http2使用了二进制协议，两边都维护了头字段的对应表，所以头已经很小了。同时http2也会保证长连接，不用每次都建立新的连接。
  - http2不是采用字符串的协议，总体大小会小很多



## 什么是Socket？

- socket 以五元组( 协议+ip+pord:ip+port)来区分，socket 会映射到内核中的一个文件描述符(file description，FD)
- 可以理解为tcp/ip的抽象层，我们通过socket来操作底层的tcp/ip。



## HTTP1.0 1.1 2.0的区别

简单概括：

- 1.1:
  - 长连接
    - 后面的请求等待前面请求的返回才能获得执行机会
  - 缓存处理
- 2.0
  - 二进制格式序列化
  - 多路复用
    - 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；
  - header压缩

https://www.jianshu.com/p/be29d679cbff



## JWT和Session？

![image.png](https://i.loli.net/2021/05/23/A1NEIJ2qsfuv6OU.png)

### 什么场景下适合用JWT？

- 一次性验证
  - 比如邮箱发验证链接，
- restfulapi的无状态认证
  - 客户端和服务端共享 secret；过期时间由服务端校验，客户端定时刷新；签名信息不可被修改。以此后端来校验前端请求者的身份。

### 为什么不推荐用JWT来做会话管理？

- 注销和修改密码怎么办？
  - session的情况下直接清空session就可以了
  - 因为jwt是无状态的，不保存在后端
    - 只清除客户端的cookie，这样用户就不会携带jwt了，但是用原来的jwt仍然可以访问
    - 清空或修改服务端应用对应的secret
      - 怎么设计一个跟用户相关的secret而不是所有用户公用的统一值？
      - 修改密码的情况下，只清除cookie是不够的，还需要修改secret
    - 借助第三方管理jwt
      - 那跟session的方案都差不多了，本来token就是无状态的，硬生生变成有状态
- 续签的问题
  - 每次请求刷新jwt
    - 性能问题
  - 快要过期的时候刷新jwt
    - 如果快过期的时候没请求，就要重新登录了
  - 完善refresh token
    - 借鉴oauth2的设计，jwt过期时间数小时，refreshToken过期时间几天。
    - 为了jwt把整个流程改了，那为什么不直接用oauth2的password和client模式呢？
  - 借助第三方管理token

## 输入一个网址发生了什么?

- DNS将网址解析成IP地址

  - 从本地缓存、浏览器缓存、路由器找缓存，没有的话向根服务器找对应的name server
  - 去name server里找对应的配置
  - 域名会有对应的Name Server, Route的Adress记录，转向IP地址
- 应用层发送一个请求，将请求从用户态转到内核态，准备去发送请求，接下来都是内核态的系统调用
- 传输层 先创建一个握手包
- 网络层 有了目标的IP地址，想将这个包传输到目的地址

  - 需要找到这个数据包的下一跳(路由器)
  - 因为路由器是这个局域网网段的，一般不会是相同的网段，照理不应该接收这个包，这个时候就在外面包了一层MAC地址
  - 路由器发现是自己的MAC地址，就拆开来，发现IP不是自己的，那么就发送给路由器的下一跳。
- 链路层 本机上可能还没有路由器的ARP地址，根据ARP协议拿到下一跳的MAC地址

  - ARP广播会找到网关的MAC地址
  - 网关上的路由表记录着下一跳地址
  - 向上图一样一直传输过去
- 到终端建立连接。。。
- tls。。
- 网关。。
- nginx。。。
- 负载均衡

### 

![image-20210408235019123](https://i.loli.net/2021/05/23/PaXC2Il6unrFOyv.png)

<img src="https://i.loli.net/2021/05/19/O8NnZta73rcCSi5.png" alt="image-20210409000152162" style="zoom: 80%;" />